# New Primitives

The building blocks of software are changing.

For decades, we built with the same primitives: databases, APIs, user flows, sessions, CRUD. These were the atoms. Everything else was just composition.

**2026 is different.** Applied AI isn't a feature — it's a force that's rewriting what primitives even mean.

When everyone has an agent, when context is ambient, when inference is infrastructure — the entire stack shifts. New atoms emerge. Old ones fade.

This isn't about "adding AI" to existing products. It's about recognizing that the **fundamental building blocks** of design, product, and engineering have changed.

---

## What Makes Something a Primitive?

A primitive is:
- **Foundational** — You build on top of it, not around it
- **Composable** — It combines with other primitives to create complexity
- **Inevitable** — Once it exists, not using it feels like a handicap

The web browser was a primitive. REST APIs were a primitive. React components were a primitive.

Now we're in a new era. Let's name the atoms.

---

## The New Stack

### **Product & Design**

1. **[Agentic Interfaces](./01-agentic-interfaces.md)** — Design for agent handoffs, not user flows
2. **[Ambient Context](./02-ambient-context.md)** — Stop asking, start knowing
3. **[Continuous Personalization](./03-continuous-personalization.md)** — Not settings, but learning surfaces
4. **[Multi-Agent Orchestration](./04-multi-agent-orchestration.md)** — Coordinating agents, not building features

### **Engineering & Architecture**

5. **[Inference as Infrastructure](./05-inference-as-infrastructure.md)** — LLM calls are the new database queries
6. **[Memory Architecture](./06-memory-architecture.md)** — RAG and vector stores as first-class citizens
7. **[Tool-Calling Protocols](./07-tool-calling-protocols.md)** — MCP as the new REST
8. **[Prompt Engineering as Code](./08-prompt-engineering-as-code.md)** — Version, test, deploy prompts like APIs
9. **[Streaming Everything](./09-streaming-everything.md)** — Token-by-token, not page-by-page
10. **[Statefulness Returns](./10-statefulness-returns.md)** — Sessions and multi-turn memory are back
11. **[Cost-Aware Execution](./11-cost-aware-execution.md)** — Token budgets as a design constraint

### **Social & Collaboration**

12. **[Agent-to-Agent Protocols](./12-agent-to-agent-protocols.md)** — Agents negotiating with agents
13. **[Provenance & Audit Trails](./13-provenance-and-audit-trails.md)** — "Who did this?" now includes agents
14. **[Collaborative Intelligence](./14-collaborative-intelligence.md)** — Sharing context, not files
15. **[Human-in-Loop by Default](./15-human-in-loop-by-default.md)** — Propose → confirm → execute

---

## The Meta-Shift

**Old way:**  
User clicks → server processes → response

**New way:**  
User states intent → agent interprets → orchestrates tools/agents → streams result → learns from feedback

**Old primitive:** Pixel-perfect UI  
**New primitive:** Conversation flows and agent handoff patterns

**Old primitive:** Deterministic code  
**New primitive:** Probabilistic systems with guardrails

---

## Why This Matters

If you're building products in 2026 and you're not thinking in these primitives, you're building on sand.

This isn't hype. It's not "AI will replace X." It's about recognizing that the atoms of software have fundamentally changed, and the products that win will be the ones built from the new periodic table.

---

**Note:** This is a living document. Some primitives are obvious (inference, agents). Others are still emerging. I'll keep refining as I learn.

Let's build.
